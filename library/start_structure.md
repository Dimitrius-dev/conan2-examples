# Структура проекта в C++

___

Для использования conan требуется повторить какие виды программных продуктов можно получить используя ЯП C++. Это делается через **CMake**.
В CMake через скрипт **CMakeLists.txt** создается **цель** - то что должно быть собрано в результате работы.

В общем случае это:
+ Библиотеки ( library )
+ Исполняемые файлы ( executable )

Исполняемые файлы являются собранными бинарными файлами, котовыми к запуску.

Любая программа на C++ состоит из файлов:
+ .h - заголовочные файлы, обозначающие структуру программного модуля.
+ .cpp - файлы реализации, обозначающие конкретный функционал ранее определенного программного модуля.

Из .cpp с включенными всеми компонентами создается *единица трансляции* (ЕТ), он же объектный файл. Все ЕТ компилируются независимо.
На каждый .cpp файл формируется объектный файл.

Программа может состоять как из .h и .cpp файлов, так и только из .h файлов.

___
## Виды библиотек

Библиотеки делятся на 3 типа:
+ **static** библиотеки
+ **shared** библиотеки
+ **interface** библиотеки


### Static библиотека
Static библиотека состоит из **.h** и **.cpp** файлов и создает файл библиотеки.

При сборке исполняемого файла, static библиотека линкуется к исполняемому файлу и **копируется в него целиком**. Таким образом файл библиотеки уже не нужен для запуска ПО.

### Shared библиотека
Shared библиотека аналогично Static библиотеке состоит из **.h** и **.cpp** файлов и создает файл библиотеки.

При сборке исполняемого файла, shared библиотека линкуется к исполняемому файлу и **не копируется в него целиком, а остается в виде отдельного файла**. Таким образом файл библиотеки нужен для любого запуска ПО.

### interface библиотека
Interface библиотека состоит только из .h файлов и не создает после себя файла библиотеки.

При сборке исполняемого файла, interface библиотека, словно обычные исходники, копируется в исполняемый файл.

### Подключение библиотеки в CMake
Значение .h и .cpp при подключении библиотеки имеют следующие значения.
На **этапе разработки** файлы **.h библиотеки** доступны программному коду, который будет использовать эту библиотеку. При этом этому же программному коду недоступны файлы .cpp.
Это связано с тем, что из cpp и .h файлов собирается бинарный файл библиотеки, который подключается к конечной программе на **этапе компиляции**. **Этап компиляции** идет после **этапа разработки**.

___
Пример сборки на CMake

### Создание исполняемый программы

program_name - название цели сборки

CMakeLists.txt
```
...
add_executable(program_name
        src/main.cpp
        src/tool.cpp
)

target_include_directories(program_name PUBLIC include)
...
```

Строение проекта
```
-CMakeLists.txt
-src
    - main.cpp
    - tool.cpp
-include
    - tool.h
```

Папка src содержит файлы реализации
Папка include содержит заголовочные файлы

### Создание static библиотеки

library_name - название цели сборки

CMakeLists.txt
```
...
add_library(library_name STATIC
        src/lib.cpp
        src/tool.cpp
)

target_include_directories(library_name <INCLUDE_TYPE> include)
target_link_libraries(library_name <LINK_TYPE> other_lib)
...
```

Строение проекта
```
-CMakeLists.txt
-src
    - lib.cpp
    - tool.cpp
-include
    - tool.h
```

Папка src содержит файлы реализации  
Папка include содержит заголовочные файлы

### Создание shared библиотеки

library_name - название цели сборки

CMakeLists.txt
```
...
add_library(library_name SHARED
        src/lib.cpp
        src/tool.cpp
)

target_include_directories(library_name <INCLUDE_TYPE> include)
target_link_libraries(library_name <LINK_TYPE> other_lib)
...
```

Строение проекта
```
-CMakeLists.txt
-src
    - lib.cpp
    - tool.cpp
-include
    - tool.h
```

Папка src содержит файлы реализации  
Папка include содержит заголовочные файлы

### Создание interface библиотеки

library_name - название цели сборки

CMakeLists.txt
```
...
add_library(library_name INTERFACE)

target_include_directories(library_name <INCLUDE_TYPE> include)
target_link_libraries(library_name <LINK_TYPE> other_lib)
...
```

Строение проекта
```
-CMakeLists.txt
-src
-include
    - lib.h
```

Папка src пустая  
Папка include содержит заголовочные файлы

___

## Виды подключения заголовочных файлов

В CMake в `target_include_directories()` ключевые слова `PUBLIC`, `PRIVATE` и `INTERFACE` управляют тем, как включаемые директории распространяются на зависимости и саму цель. Они используются для контроля видимости заголовочных файлов в зависимости от типа цели.

### `PRIVATE`
- Директории включаются **только** для компиляции самой цели, но **не** передаются зависимым целям.
- Используется для заголовочных файлов, которые нужны **только внутри** этой цели.

**Пример:**
   ```cmake
   target_include_directories(my_lib PRIVATE ${CMAKE_SOURCE_DIR}/include)
   ```
Здесь `include` будет доступен только внутри `my_lib`, но не у зависимых от неё целей.

---

### `PUBLIC`
- Директории включаются **как для компиляции самой цели, так и для её зависимостей**.
- Используется, когда библиотека или цель **предоставляет** заголовочные файлы своим пользователям.

**Пример:**
   ```cmake
   target_include_directories(my_lib PUBLIC ${CMAKE_SOURCE_DIR}/include)
   ```
Здесь `include` будет доступен как при компиляции `my_lib`, так и у зависимых от неё целей.

---

### `INTERFACE`
- Директории **не** используются для компиляции самой цели, но **доступны для зависимых целей**.
- Применяется в **интерфейсных библиотеках** (`INTERFACE`-библиотеки в CMake).

**Пример:**
   ```cmake
   add_library(my_interface_lib INTERFACE)
   target_include_directories(my_interface_lib INTERFACE ${CMAKE_SOURCE_DIR}/include)
   ```
Здесь `include` будет доступен только для целей, которые используют `my_interface_lib`, но сама `my_interface_lib` не требует компиляции.

---

### Когда что использовать?
| Ключевое слово  | Доступность для цели | Доступность для зависимых целей | Используется в |
|---------------|------------------|------------------|---------------|
| `PRIVATE`    | ✅ Да            | ❌ Нет           | Внутренние заголовки |
| `PUBLIC`     | ✅ Да            | ✅ Да            | Библиотеки, предоставляющие API |
| `INTERFACE`  | ❌ Нет           | ✅ Да            | Интерфейсные библиотеки |

Использование `target_include_directories()` с правильным типом видимости позволяет правильно управлять зависимостями и избежать ненужного распространения заголовочных файлов.

___
## Виды линковки сторонних библиотек к проекту

В CMake ключевые слова `PUBLIC`, `PRIVATE` и `INTERFACE` в `target_link_libraries()` управляют тем, как зависимости распространяются на связанные цели. Они определяют, как библиотеки передаются при линковке и какие компиляторные флаги используются.

## Разбор `PUBLIC`, `PRIVATE`, `INTERFACE` в `target_link_libraries()`

### `PRIVATE`
- Заданная библиотека **используется только при линковке текущей цели**.
- Не передаёт зависимость другим целям, даже если они ссылаются на текущую.

**Пример:**
   ```cmake
   target_link_libraries(my_app PRIVATE my_lib)
   ```
- `my_lib` будет **связана** с `my_app`, но зависимые от `my_app` цели **не унаследуют** её.

---

### `PUBLIC`
- Библиотека используется **и самой целью, и её зависимыми целями**.
- Это означает, что если другая цель будет зависеть от `my_app`, она **автоматически** получит доступ к `my_lib`.

**Пример:**
   ```cmake
   target_link_libraries(my_app PUBLIC my_lib)
   ```
- `my_lib` будет **линковаться** с `my_app` **и** передаваться всем, кто ссылается на `my_app`.

---

### `INTERFACE`
- Библиотека **не используется** при линковке самой цели, но передаётся зависимым целям.
- Полезно для **интерфейсных** библиотек или заголовочных-only (`header-only`) библиотек.

**Пример:**
   ```cmake
   add_library(my_interface_lib INTERFACE)
   target_link_libraries(my_interface_lib INTERFACE my_lib)
   ```
- `my_interface_lib` не требует линковки с `my_lib`, но все цели, которые ссылаются на `my_interface_lib`, будут автоматически ссылаться на `my_lib`.

---

## Когда что использовать?

| Ключевое слово | Линкуется с текущей целью? | Передаётся зависимым целям? | Используется для |
|--------------|---------------------|------------------|------------------|
| `PRIVATE`   | ✅ Да               | ❌ Нет          | Внутренние зависимости |
| `PUBLIC`    | ✅ Да               | ✅ Да           | Библиотеки, предоставляющие API |
| `INTERFACE` | ❌ Нет              | ✅ Да           | Интерфейсные и header-only библиотеки |

### Сравнение с `target_include_directories()`
- В `target_include_directories()` речь идёт **о заголовочных файлах**, а в `target_link_libraries()` — **о зависимостях** при линковке.
- `INTERFACE` в `target_include_directories()` указывает на путь к заголовочным файлам, а в `target_link_libraries()` определяет зависимости, передающиеся далее.

### Итог
- Используйте **`PRIVATE`**, если библиотека нужна только для **этой** цели.
- Используйте **`PUBLIC`**, если библиотека нужна и **этой** цели, и **её зависимым**.
- Используйте **`INTERFACE`**, если библиотека нужна **только зависимым** (например, header-only).

___
## Примечание

Представим следующую ситуацию.
Имеется несколько зависимых cmake целей:

```
executable_project <-- lib_a <-- lib_b
```
`executable_project` - выполняемая программа  
`lib_a` - static/shared библиотека   
`lib_b` - static/shared библиотека   


Хорошей практикой считается использование следующих правил:
1. Библиотека `lib_a` **не использует** в своих заголовочных файлах (.h) элементы `lib_b` библиотеки, а если **использует**, то только в файлах реализации (.cpp) (см. паттерн pimpl).
2. Конечная выполняемая программа `executable_project` **имеет** доступ к заголовочным файлам (.h) библиотеки элементы `lib_a`, но **не имеет** доступа к заголовочным файлам (.h) библиотеки элементы `lib_b`.